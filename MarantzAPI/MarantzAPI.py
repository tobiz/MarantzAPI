import subprocess 
#import shlex
#from subprocess import Popen
from subprocess import Popen,PIPE
import time
import string
import socket
import sys

from selenium.webdriver.common.keys import Keys
from selenium.common.exceptions import NoSuchElementException
from selenium.webdriver.support.select import Select
from selenium.webdriver.firefox.options import Options

from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as cond
from selenium.common.exceptions import NoAlertPresentException
from selenium.common.exceptions import TimeoutException

from selenium.webdriver.support import expected_conditions as EC


# Generated by Selenium IDE
#import pytest
import time
import json
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities


#import MarantzAPI_test


class IP():    
    #def __init__(self, script, ip, port, timer, av_url, browser):   
    def __init__(self, port, timer, av_url, browser):
        print ("MarantzAPI with brackets")
        self.script = "./nc.sh"
        self.ip = av_url
        self.port = port
        self.timer = timer  # threading.Timer(10, self.disconnect)
                
        #print "url_chain: ", self.url_chain
        self.browser = browser
                
    def startBrowser(self, name):
    #
    # Browsers intended to be supported: firefox, chrome, ie, phantomjs
    # It has only been tested with Firefox, other browsers require code 
    # changes throughout.
    #
    # This code was finally worked out using the Selenium IDE software, a really
    # excellent piece of kit if perhaps lacking in the UI department.
    #
        try:
            if name == "firefox" or name == "Firefox" or name == "ff":
                #print("start browser name :Firefox")
                self.options = Options()
                self.options.headless = True
                driver = webdriver.Firefox(options=self.options)
                return driver
            elif name == "chrome" or name == "Chrome":
                print("start browser name :Chrome")
                driver = webdriver.Chrome()
                return driver
            elif name == "ie" or name == "Ie":
                print("start browser name :Ie")
                driver = webdriver.Ie()
                return driver
            elif name == "phantomjs" or name == "Phantomjs":
                print("start browser name :phantomjs")
                driver = webdriver.PhantomJS()
                return driver
            else:
                print ("Browser not supported")
        except Exception as msg:
            print("message: %s" % str(msg))

        
        
    #
    # <Start>
    # It might be possible to use the following rather than netcat - for later!
    #
    
    def netcat(hostname, port, content):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((hostname, port))
        s.sendall(content)
        s.shutdown(socket.SHUT_WR)
        while 1:
            data = s.recv(1024)
            if data == "":
                break
            print ("Received:", repr(data))
        print ("Connection closed.")
        s.close()
        
    #
    # <\Start>
    #
     
    def write(self, command): 
        self.parms_str = "%s \"%s\" %s %s %s" % (str(self.script), str(command), str(self.ip), str(self.port), str(self.timer))
        #print "Command str is: ", self.parms_str 
        try:
            proc = Popen(self.parms_str, shell=True, stdin=PIPE, stderr=PIPE, stdout=PIPE)
        except:
            print ("netcat failed")
            exit()
        res = proc.communicate()[0]
        
        if sys.version_info[0] < 3:
            lst = string.split(res, "\r")               #Python 2.7 Result ["Start\nano_string1", "ano_string2, ... , "End\n" ]
        else:
            res = res.decode()
            lst = res.split("\r")                       #Python 3.x Result ["Start\nano_string1", "ano_string2, ... , "End\n" ]
        #print ("Output list1: ", lst)
        lst.remove("")
        #print "Final Output list: ", lst
        print ("Returned:   ", lst, "\n")
        
        time.sleep(self.timer)
        #print "Output strt: ", proc.communicate(), "\nOutput end"
        #return res
        return lst
        
    def write_command(self, command):
        print ("Command is: ", command)
        rtn = self.write(command)
        return rtn
    
    def amp_assign(self, assign_mode):
        #
        # This function changes the Amp Assign mode by interfacing with
        # the web browser access to the AV Amp itself.  It has not been possible to do this
        # from the RS-232C/IP command set.  The Amp Assign mode needs to be set in order
        # to configure the speaker configurations from the command set.  This situation is mentioned
        # in a footnote in the command set definition spreadsheet
        #
        child = {'Surround Back':1, 'ZONE2':2, 'Bi-Amp':3, 'Front B':4, 'Front Height':5}
        self.driver = self.startBrowser(self.browser)
        self.driver.get("http://192.168.1.47/SETUP/SPEAKERS/AMPASSIGN/f_speakersetup.asp")
        self.driver.switch_to.frame(1)
        self.driver.find_element(By.NAME, "listAmpAssignMode").click()
        dropdown = self.driver.find_element(By.NAME, "listAmpAssignMode")
        
        element = "//option[. = " + "\'" + assign_mode + "\'" + "]"
        #print "Element is: ", element
        dropdown.find_element(By.XPATH, element).click()
        
        child_n = child[assign_mode]
        option = "option:nth-child(" + str(child_n) +  ")"
        #print "Option is: ", option
        self.driver.find_element(By.CSS_SELECTOR, option).click()
        
        self.driver.quit()


